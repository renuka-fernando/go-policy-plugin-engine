package main

import (
	"flag"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/mod/modfile"
)

type PolicyInfo struct {
	ModulePath string
	Package    string
	TypeName   string
}

func main() {
	policiesDir := flag.String("policies", "/policies", "Directory containing policy modules")
	outputFile := flag.String("output", "/app/core/imports.go", "Output file for generated imports")
	flag.Parse()

	log.Printf("Scanning policies in: %s", *policiesDir)

	policies, err := discoverPolicies(*policiesDir)
	if err != nil {
		log.Fatalf("Failed to discover policies: %v", err)
	}

	log.Printf("Found %d policies", len(policies))
	for _, p := range policies {
		log.Printf("  - %s (%s.%s)", p.ModulePath, p.Package, p.TypeName)
	}

	if err := generateImports(policies, *outputFile); err != nil {
		log.Fatalf("Failed to generate imports: %v", err)
	}

	log.Printf("Successfully generated imports at: %s", *outputFile)
}

func discoverPolicies(policiesDir string) ([]PolicyInfo, error) {
	var policies []PolicyInfo

	// Check if policies directory exists
	if _, err := os.Stat(policiesDir); os.IsNotExist(err) {
		log.Printf("Warning: Policies directory does not exist: %s", policiesDir)
		return policies, nil
	}

	entries, err := os.ReadDir(policiesDir)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		policyDir := filepath.Join(policiesDir, entry.Name())
		goModPath := filepath.Join(policyDir, "go.mod")

		// Check if go.mod exists
		if _, err := os.Stat(goModPath); os.IsNotExist(err) {
			log.Printf("Skipping %s: no go.mod found", entry.Name())
			continue
		}

		// Parse go.mod to get module path
		modulePath, err := parseGoMod(goModPath)
		if err != nil {
			log.Printf("Warning: Failed to parse go.mod in %s: %v", entry.Name(), err)
			continue
		}

		// Find policy implementations in this module
		policyInfos, err := findPolicyImplementations(policyDir, modulePath)
		if err != nil {
			log.Printf("Warning: Failed to find policies in %s: %v", entry.Name(), err)
			continue
		}

		policies = append(policies, policyInfos...)
	}

	return policies, nil
}

func parseGoMod(goModPath string) (string, error) {
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", err
	}

	mod, err := modfile.Parse(goModPath, data, nil)
	if err != nil {
		return "", err
	}

	return mod.Module.Mod.Path, nil
}

func findPolicyImplementations(dir, modulePath string) ([]PolicyInfo, error) {
	var policies []PolicyInfo

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		// Parse the Go file
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			log.Printf("Warning: Failed to parse %s: %v", path, err)
			return nil
		}

		packageName := node.Name.Name

		// For simplicity, we'll use a naming convention:
		// Look for a file named "policy.go" and assume it has a type named "Policy"
		if filepath.Base(path) == "policy.go" {
			policies = append(policies, PolicyInfo{
				ModulePath: modulePath,
				Package:    packageName,
				TypeName:   "Policy", // Convention: main type is named "Policy"
			})
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return policies, nil
}

func generateImports(policies []PolicyInfo, outputFile string) error {
	templateStr := `package main

// This file is AUTO-GENERATED by import-generator
// DO NOT EDIT MANUALLY

{{if .Policies}}
import (
{{range $i, $p := .Policies}}	policy{{$i}} "{{$p.ModulePath}}"
{{end}})

func init() {
{{range $i, $p := .Policies}}	RegisterPolicy(&policy{{$i}}.{{$p.TypeName}}{})
{{end}}}
{{else}}
// No policies found

func init() {
	// No policies to register
}
{{end}}
`

	t, err := template.New("imports").Parse(templateStr)
	if err != nil {
		return err
	}

	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	data := struct {
		Policies []PolicyInfo
	}{
		Policies: policies,
	}

	if err := t.Execute(f, data); err != nil {
		return err
	}

	return nil
}
